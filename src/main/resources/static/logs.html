<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Монитор логов</title>
  <style>
    body { font-family: Arial, sans-serif; font-size: 12px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 3px 5px; }
    th { background-color: #f2f2f2; position: sticky; top: 0; z-index: 1; }
    tr.session-marker { background-color: #ffeeba; }
    tr.commented { background-color: #ffebee; }
    tr.commented-green { background-color: #e8f5e9; }
    td.commented-cell { border-color: #f44336; box-shadow: inset 0 0 0 1px #f44336; }
    td.commented-cell-green { border-color: #4caf50; box-shadow: inset 0 0 0 1px #4caf50; }
    .empty-row {
      height: 15px;
      background-color: #f5f5f5;
    }
    #commentBox { position: fixed; right: 10px; bottom: 10px; width: 340px;
      border: 1px solid #ccc; padding: 8px; background: #fff; }
    #commentBox.hidden { display: none; }
    #logContainer { max-height: 80vh; overflow-x: auto; overflow-y: auto; }
    .cell-long {
      max-width: 260px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .editable-cell {
      cursor: pointer;
      position: relative;
    }
    .editable-cell:hover {
      background-color: #f0f8ff;
    }
    .input-edit {
      width: 100%;
      padding: 2px;
      border: 1px solid #ccc;
      border-radius: 2px;
      box-sizing: border-box;
    }
    .delete-btn {
      background-color: #f44336;
      color: white;
      border: none;
      padding: 2px 5px;
      cursor: pointer;
      font-size: 10px;
      border-radius: 3px;
    }
    .delete-btn:hover {
      background-color: #d32f2f;
    }
    .color-selector {
      margin-top: 8px;
      display: flex;
      align-items: center;
    }
    .color-option {
      margin-right: 10px;
      display: flex;
      align-items: center;
    }
    .color-circle {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      margin-right: 5px;
      cursor: pointer;
      border: 2px solid transparent;
    }
    .color-circle.selected {
      border-color: #333;
    }
    .red-color {
      background-color: #f44336;
    }
    .green-color {
      background-color: #4caf50;
    }
  </style>
</head>
<body>
<h3>Монитор логов</h3>
<div id="logContainer">
  <table id="logTable">
    <thead>
    <tr>
      <th>#</th>
      <th>Удалить</th>
      <th>Кейсы</th>
      <th>Действие</th>
      <th>str_par</th>
      <th>number</th>
      <th>date_add</th>
      <th>id_order</th>
      <th>category_id</th>
      <th>button_name</th>
      <th>id_screen</th>
      <th>id_element</th>
      <th>action</th>
      <th>formname</th>
      <th>search_bar</th>
      <th>search_bar_fixed</th>
      <th>tovs_subscribe_shown</th>
      <th>rn_tov</th>
      <th>tovs_rn_shown_sort</th>
      <th>tovs_rn_shown_discount_sort</th>
      <th>falseteasers_shown</th>
      <th>[id_tov]</th>
      <th>tov_reason_array_real</th>
      <th>tovs_rn_na_sort</th>
      <th>tovs_rn_real_sort</th>
      <th>rn_green</th>
      <th>rn_max</th>
      <th>tovs_rn_archive</th>
      <th>name_tov</th>
      <th>tovs_rn_archive_sort</th>
      <th>widget_id</th>
      <th>widget_type</th>
      <th>widget_title</th>
      <th>group_list</th>
      <th>boost_array</th>
      <th>id_tov_boost_array</th>
      <th>position_boost_array</th>
      <th>id_split_array</th>
      <th>boost_na_array</th>
      <th>id_tov_boost_na_array</th>
      <th>position_boost_na_array</th>
      <th>id_cohort</th>
      <th>id_split_na_array</th>
      <th>tov_reason</th>
      <th>tov_reason_array_na</th>
      <th>ref_widget_id</th>
      <th>section_name</th>
      <th>shop_list</th>
      <th>shop_list_full</th>
      <th>rn_learn</th>
      <th>pers_listing</th>
      <th>pers_tov</th>
      <th>id_tov_boost</th>
      <th>[id_boost]</th>
      <th>[boost_position]</th>
      <th>product_detail</th>
      <th>iminshop</th>
      <th>chosenmark</th>
      <th>specialmark</th>
      <th>lp_today</th>
      <th>lp_tomorrow</th>
      <th>amount</th>
      <th>cart_qty</th>
      <th>stock</th>
    </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<div id="commentBox" class="hidden">
  <div><b>Комментарий к строке <span id="commentRowIndex"></span>,
    колонка <span id="commentColIndex"></span></b></div>
  <textarea id="commentText" rows="4" style="width: 100%;"></textarea>

  <div class="color-selector">
    <div class="color-option">
      <div class="color-circle red-color selected" data-color="red"></div>
      <label>Красный</label>
    </div>
    <div class="color-option">
      <div class="color-circle green-color" data-color="green"></div>
      <label>Зеленый</label>
    </div>
  </div>

  <div style="margin-top: 6px; text-align: right;">
    <button onclick="closeComment()">Отмена</button>
    <button onclick="saveComment()">Сохранить</button>
  </div>
</div>

<script>
  const tableBody = document.querySelector('#logTable tbody');
  const commentBox = document.getElementById('commentBox');
  const commentRowIndexSpan = document.getElementById('commentRowIndex');
  const commentColIndexSpan = document.getElementById('commentColIndex');
  const commentTextArea = document.getElementById('commentText');

  // Количество колонок в таблице (для span в пустой строке)
  const colCount = document.querySelectorAll('#logTable thead th').length;

  // comments[rowIndex][colIndex] = {text: '', color: ''}
  let comments = {};

  // Переменные для группировки логов
  let logGroupTimer = null;
  let pendingLogs = [];

  // Данные логов (для сохранения изменений и удаления)
  let logDataArray = [];
  let rowMapping = []; // сопоставление строк таблицы с индексами в logDataArray

  function formatShort(value) {
    if (!value) return '';
    const parts = value.split(/[,;]/);
    if (parts.length <= 4) return value;
    return parts.slice(0, 4).join(',') + ' ...';
  }

  function addRow(columns, initial) {
    const row = document.createElement('tr');
    const index = tableBody.rows.length + 1;

    // Сохраняем данные для возможного редактирования и удаления
    const logDataIndex = logDataArray.length;
    const logData = [...columns];
    logDataArray.push(logData);
    rowMapping.push(logDataIndex);

    const caseName = columns.length > 0 ? columns[0] : '';
    if (caseName && caseName.indexOf('НОВАЯ_СЕССИЯ') === 0) {
      row.classList.add('session-marker');
    }

    const idxCell = document.createElement('td');
    idxCell.textContent = index;
    row.appendChild(idxCell);

    // Добавляем кнопку удаления
    const deleteCell = document.createElement('td');
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.title = 'Удалить строку';
    deleteBtn.addEventListener('click', function() {
      deleteRow(row, logDataIndex);
    });
    deleteCell.appendChild(deleteBtn);
    row.appendChild(deleteCell);

    for (let i = 0; i < columns.length; i++) {
      const cell = document.createElement('td');
      const value = columns[i] || '';

      const rowIndex = index;
      const colIndex = i + 2; // 0-я колонка — номер, 1-я — удалить, 2-я — кейсы

      // только str_par (i === 2) показываем в сокращённом виде
      if (i === 2) {
        const shortVal = formatShort(value);
        cell.classList.add('cell-long');
        cell.setAttribute('data-full', value);
        cell.setAttribute('data-short', shortVal);
        cell.setAttribute('data-expanded', 'false');
        cell.textContent = shortVal;
        cell.title = value; // полный текст по hover
      } else {
        cell.textContent = value;
      }

      // Сделать колонку "Кейсы" (индекс 0 в данных) редактируемой
      if (i === 0) { // колонка "Кейсы" в данных
        cell.classList.add('editable-cell');
        cell.setAttribute('data-row-index', logDataIndex); // индекс в массиве данных
        cell.setAttribute('data-col-index', 0); // индекс колонки в данных

        cell.addEventListener('dblclick', function() {
          editCell(this, logDataIndex, 0);
        });
      }

      cell.addEventListener('click', function () {
        // сначала логика сворачивания/разворачивания для str_par
        if (i === 2) {
          const expanded = cell.getAttribute('data-expanded') === 'true';
          const full = cell.getAttribute('data-full');
          const shortVal = cell.getAttribute('data-short');
          cell.setAttribute('data-expanded', expanded ? 'false' : 'true');
          cell.textContent = expanded ? shortVal : full;
        }
        // затем открываем окно комментария
        openComment(rowIndex, colIndex, cell);
      });

      const existing = getComment(rowIndex, colIndex);
      if (existing) {
        // Применяем стиль в зависимости от цвета комментария
        if (existing.color === 'green') {
          cell.classList.add('commented-cell-green');
          row.classList.add('commented-green');
        } else {
          cell.classList.add('commented-cell');
          row.classList.add('commented');
        }
        // title уже может быть для str_par, поэтому дополняем
        const baseTitle = cell.title || value;
        cell.title = baseTitle + "\n\nКомментарий: " + existing.text;
      }

      row.appendChild(cell);
    }

    tableBody.appendChild(row);

    if (!initial) {
      const container = document.getElementById('logContainer');
      container.scrollTop = container.scrollHeight;
    }
  }

  // Функция для удаления строки
  function deleteRow(rowElement, logDataIndex) {
    if (confirm('Вы уверены, что хотите удалить эту строку?')) {
      // Найдем индекс строки в таблице
      const rowIndexInTable = Array.from(tableBody.children).indexOf(rowElement);

      // Удаляем из DOM
      rowElement.remove();

      // Удаляем из массива данных
      logDataArray.splice(logDataIndex, 1);

      // Обновляем mapping
      rowMapping = rowMapping.filter(index => index !== logDataIndex);

      // Пересчитываем индексы в rowMapping
      for (let i = 0; i < rowMapping.length; i++) {
        if (rowMapping[i] > logDataIndex) {
          rowMapping[i]--;
        }
      }

      // Обновляем номера строк
      updateRowNumbers();
    }
  }

  // Функция для обновления номеров строк
  function updateRowNumbers() {
    const rows = tableBody.querySelectorAll('tr');
    rows.forEach((row, index) => {
      const firstCell = row.cells[0]; // номер строки
      if (firstCell) {
        firstCell.textContent = index + 1;
      }
    });
  }

  // Функция для редактирования ячейки
  function editCell(cell, dataIndex, colIndex) {
    const currentValue = logDataArray[dataIndex][colIndex] || '';

    // Создаем input для редактирования
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'input-edit';
    input.value = currentValue;
    input.style.width = '100%';

    // Сохраняем старое значение для отмены
    const originalContent = cell.innerHTML;

    // Заменяем содержимое ячейки на input
    cell.innerHTML = '';
    cell.appendChild(input);
    input.focus();
    input.select();

    // Функция для сохранения изменений
    function saveChanges() {
      if (input.value !== currentValue) {
        // Обновляем данные
        logDataArray[dataIndex][colIndex] = input.value;

        // Обновляем отображение
        cell.innerHTML = input.value;
        cell.classList.add('editable-cell');

        // Восстанавливаем события
        cell.addEventListener('dblclick', function() {
          editCell(this, dataIndex, colIndex);
        });
      } else {
        // Если значение не изменилось, просто восстанавливаем ячейку
        cell.innerHTML = originalContent;
        cell.classList.add('editable-cell');

        // Восстанавливаем события
        cell.addEventListener('dblclick', function() {
          editCell(this, dataIndex, colIndex);
        });
      }
    }

    // Обработчики событий для сохранения изменений
    input.addEventListener('blur', saveChanges);

    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        saveChanges();
      } else if (e.key === 'Escape') {
        // Отмена редактирования
        cell.innerHTML = originalContent;
        cell.classList.add('editable-cell');

        // Восстанавливаем события
        cell.addEventListener('dblclick', function() {
          editCell(this, dataIndex, colIndex);
        });
      }
    });
  }

  function getComment(rowIndex, colIndex) {
    const rowComments = comments[rowIndex];
    if (!rowComments) return null;
    return rowComments[colIndex] || null;
  }

  function setComment(rowIndex, colIndex, text, color) {
    if (!comments[rowIndex]) {
      comments[rowIndex] = {};
    }
    comments[rowIndex][colIndex] = {text: text, color: color};
  }

  function openComment(rowIndex, colIndex, cell) {
    commentRowIndexSpan.textContent = rowIndex;
    commentColIndexSpan.textContent = colIndex;
    commentBox.dataset.rowIndex = rowIndex;
    commentBox.dataset.colIndex = colIndex;

    const existing = getComment(rowIndex, colIndex);
    if (existing) {
      commentTextArea.value = existing.text || '';
      // Устанавливаем выбранный цвет
      document.querySelectorAll('.color-circle').forEach(circle => {
        circle.classList.remove('selected');
      });
      const selectedColor = existing.color || 'red';
      document.querySelector(`.color-circle[data-color="${selectedColor}"]`).classList.add('selected');
    } else {
      commentTextArea.value = '';
      // По умолчанию красный цвет
      document.querySelectorAll('.color-circle').forEach(circle => {
        circle.classList.remove('selected');
      });
      document.querySelector('.color-circle[data-color="red"]').classList.add('selected');
    }

    commentBox.classList.remove('hidden');
    commentTextArea.focus();
  }

  function closeComment() {
    commentBox.classList.add('hidden');
  }

  function saveComment() {
    const rowIndex = parseInt(commentBox.dataset.rowIndex, 10);
    const colIndex = parseInt(commentBox.dataset.colIndex, 10);
    const text = commentTextArea.value || '';

    // Получаем выбранный цвет
    const selectedColorCircle = document.querySelector('.color-circle.selected');
    const color = selectedColorCircle ? selectedColorCircle.dataset.color : 'red';

    setComment(rowIndex, colIndex, text, color);

    const rows = tableBody.rows;
    if (rowIndex >= 1 && rowIndex <= rows.length) {
      const row = rows[rowIndex - 1];
      const cell = row.cells[colIndex];

      const baseValue = cell.textContent || '';
      const baseTitle = cell.getAttribute('data-full') || cell.title || baseValue;

      if (text) {
        // Удаляем предыдущие классы
        cell.classList.remove('commented-cell', 'commented-cell-green');
        row.classList.remove('commented', 'commented-green');

        // Применяем стиль в зависимости от цвета
        if (color === 'green') {
          cell.classList.add('commented-cell-green');
          row.classList.add('commented-green');
        } else {
          cell.classList.add('commented-cell');
          row.classList.add('commented');
        }

        cell.title = baseTitle + "\n\nКомментарий: " + text;
      } else {
        cell.classList.remove('commented-cell', 'commented-cell-green');
        row.classList.remove('commented', 'commented-green');

        const rowComments = comments[rowIndex] || {};
        const hasAny = Object.keys(rowComments).some(function (k) {
          const comment = rowComments[k];
          return comment && comment.text && comment.text.length > 0;
        });
        if (hasAny) {
          // Если в строке есть другие комментарии, определяем цвет по первому найденному
          for (let k in rowComments) {
            const comment = rowComments[k];
            if (comment && comment.text && comment.text.length > 0) {
              if (comment.color === 'green') {
                row.classList.add('commented-green');
              } else {
                row.classList.add('commented');
              }
              break;
            }
          }
        }
      }
    }

    closeComment();
  }

  // Добавляем обработчики для выбора цвета
  document.querySelectorAll('.color-circle').forEach(circle => {
    circle.addEventListener('click', function() {
      document.querySelectorAll('.color-circle').forEach(c => {
        c.classList.remove('selected');
      });
      this.classList.add('selected');
    });
  });

  // Функция для добавления лога в группу
  function addToLogGroup(columns) {
    pendingLogs.push(columns);

    // Очищаем предыдущий таймер
    if (logGroupTimer) {
      clearTimeout(logGroupTimer);
    }

    // Устанавливаем таймер на 1 секунду
    logGroupTimer = setTimeout(() => {
      // Добавляем все накопленные логи
      pendingLogs.forEach(logData => {
        addRow(logData, false);
      });

      // Добавляем пустую строку после группы
      const emptyRow = document.createElement('tr');
      emptyRow.classList.add('empty-row');
      const emptyCell = document.createElement('td');
      emptyCell.colSpan = colCount;
      emptyRow.appendChild(emptyCell);
      tableBody.appendChild(emptyRow);

      // Очищаем очередь
      pendingLogs = [];

      // Прокручиваем вниз
      const container = document.getElementById('logContainer');
      container.scrollTop = container.scrollHeight;
    }, 1000); // 1 секунда ожидания перед добавлением группы
  }

  async function loadInitial() {
    try {
      const resp = await fetch('/logs/last?limit=50');
      if (!resp.ok) return;
      const data = await resp.json();
      data.forEach(function (rec) {
        const cols = rec.columns || rec;
        addRow(cols, true);
      });
    } catch (e) {
      console.error('Error loading initial logs', e);
    }
  }

  function connectSse() {
    const es = new EventSource('/logs/stream');
    es.addEventListener('log', function (event) {
      try {
        const cols = JSON.parse(event.data);
        addToLogGroup(cols); // Используем новую функцию для группировки
      } catch (e) {
        console.error('Error in SSE event', e);
      }
    });
    es.onerror = function (e) {
      console.error('SSE error', e);
    };
  }

  loadInitial();
  connectSse();
</script>
</body>
</html>